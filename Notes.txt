//React.createElement =>React Element - JS Object => HTMLElement(Readable by Browser)

const heading = React.createElement("h1", {}, "Hello world from React!");



// JSX (Transpiled befoore it reahes the JS Engine) - PARCEL - BABEL
//JSX => Babel transpiles it to React.createElement => React Element - JS Object => HTMLElement(Readable

const jsxHeading = <h1>This is Hello From JSX</h1>;

Functional Component => A function which returns a React component or piece of JSX code.

Component Composition => Using a component inside a component.
Eg -
const Title = () => <h1>Namaste React</h1>;
const HeadingComponent = () => {
  return (
    <div className="container">
      <Title />
      <h1>This is h1</h1>
      <h2>This is h2</h2>
    </div>
  );
};

Important Points on useEffect -

1. if no dependency array => called on every render
Eg-
useEffect(()=>{
	console.log("useEffect called);
})

2. if dependency array is blank = [] => called on initial render (only once)
Eg-
useEffect(()=>{
	console.log("useEffect called);
},[])

3. if dependency array is [dependency] => called everytime dependency is updated.



Assignement - 1

1. What is Emmet?
Emmet is a plugin used in text editors and IDEs that helps web developers write HTML and CSS code faster by using shorthand abbreviations that expand into full code snippets with a single command. It improves productivity and reduces repetitive typing tasks in web development.




2. Difference between Library and Framework?
The main difference between a library and a framework lies in their fundamental roles and the control they offer to developers:

1. Library:
- A library is a collection of pre-written code or functions that developers can use to perform specific tasks or solve particular problems.
- Developers have control over when and how they use the library's functionalities. They can call specific functions or methods from the library whenever needed in their code.
- Libraries are often seen as "tools" that developers can use to accomplish specific tasks, but they need to write the overall structure and flow of their application themselves.

2. Framework:
- A framework is a more comprehensive and structured set of tools and guidelines that dictate the architecture and flow of an application.
- Developers work within the framework's structure and follow its design patterns, which provides a standardized way to build applications.
- Frameworks control the overall flow of the application and provide "inversion of control," meaning the framework calls the developer's code rather than the developer explicitly calling framework code.
- Developers fill in the details and extend the framework by creating custom code, but they need to follow the framework's conventions and rules.

In summary, a library is more like a collection of utilities or tools that developers can use as needed, whereas a framework is a complete set of guidelines and structures that developers follow to build an application. A library gives developers more control, while a framework provides a structured environment and dictates how the application should be built.




3. What is CDN? Why do we use it ?
CDN stands for Content Delivery Network. It is a network of distributed servers strategically located in different geographic locations to efficiently deliver web content to users. The primary purpose of using a CDN is to improve the performance, reliability, and availability of websites and web applications.

When you visit a website that uses a CDN, here's how it works:

1. Content Replication: The website's static files, such as images, CSS, JavaScript, videos, and other assets, are duplicated and stored on multiple servers across the CDN's network.

2. Proximity to Users: The CDN servers are strategically positioned in various locations around the world, closer to the end-users. This geographical distribution reduces the distance between the user and the server, resulting in lower latency and faster data transfer.

3. Faster Content Delivery: When a user requests content from the website, the CDN routes the request to the nearest server with the required content. This reduces the time taken to fetch the data, leading to faster loading times for web pages and better user experience.

4. Load Distribution: CDNs can also distribute the load on the servers, helping to prevent website crashes during traffic spikes or DDoS attacks. When there's high demand, the CDN can route requests to less busy servers, ensuring smoother performance.

5. Improved Reliability: With multiple server locations, if one server goes down, the CDN can automatically route requests to another available server, ensuring continuous availability of content.

Key reasons why CDNs are used:

1. Faster Load Times: CDNs significantly reduce the time it takes for web pages to load, which is crucial for retaining visitors and reducing bounce rates.

2. Global Scalability: CDNs allow websites to handle traffic from users worldwide without compromising performance, ensuring a consistent user experience across the globe.

3. High Availability: CDNs improve the availability and reliability of websites, reducing downtime and minimizing the risk of server failures.

4. Bandwidth Savings: By offloading static content to CDN servers, the origin server's load is reduced, resulting in cost savings on bandwidth and server resources.

5. Security: CDNs often offer security features like DDoS protection and SSL support, enhancing the overall security posture of the website.

Overall, CDNs are essential tools for modern web development, as they enhance website performance, availability, and user experience, while also helping to manage and optimize the distribution of content to a global audience.




4. Why is React known as React?
React is named so because it embodies the idea of "reactive programming," where components automatically update the user interface in response to changes in data or state. It was developed by Facebook and is known for its simplicity, efficiency, and component-based approach to building user interfaces.




5. What is cross-origin in script tag ?
In the context of web development, the term "cross-origin" in the script tag refers to a security restriction that browsers enforce to prevent scripts loaded from one origin (domain, protocol, and port) from making requests to a different origin. An origin is considered "cross-origin" if any of the following components differ between two URLs:

1. Protocol (e.g., http:// and https://)
2. Domain (e.g., example.com and subdomain.example.com)
3. Port (e.g., example.com:80 and example.com:8080)

This security feature is known as the "Same-Origin Policy," and it is a fundamental part of web security to prevent unauthorized access to sensitive data and to mitigate potential security vulnerabilities, such as Cross-Site Scripting (XSS) attacks.

When you include a script tag in an HTML document to load an external JavaScript file, the browser will restrict the execution of that script if it is loaded from a different origin. This means that the script will not be able to access resources, variables, or functions defined in the hosting page or make direct requests to APIs on a different origin.

However, there are ways to enable cross-origin access if it is required for specific scenarios. One common method is to use Cross-Origin Resource Sharing (CORS) headers on the server-side, which allows the server to specify which origins are allowed to access its resources.

It's important to note that cross-origin restrictions apply to modern web browsers. Older versions of Internet Explorer (before IE 10) might have slightly different security mechanisms and restrictions. Therefore, it's essential to be aware of these security considerations while developing web applications to ensure proper handling of cross-origin requests and to avoid potential security vulnerabilities.




5. What is the difference between React and ReactDOM?
React and ReactDOM are two distinct packages in the React ecosystem, and they serve different purposes:

1. React:
React is the core library of the React ecosystem. It is a JavaScript library for building user interfaces, particularly focused on creating UI components and managing the application state. React provides the fundamental APIs and features that enable developers to build interactive and reusable UI components in a declarative manner.

Key features of React include:
- Components: React allows developers to create reusable UI components that encapsulate their logic and rendering.
- Virtual DOM: React uses a Virtual DOM to efficiently update the actual DOM, reducing the number of direct manipulations and improving performance.
- JSX: React introduces JSX (JavaScript XML), a syntax extension that allows developers to write HTML-like code in JavaScript for rendering components.

2. ReactDOM:
ReactDOM is a package that provides the necessary methods for integrating React with the browser's DOM (Document Object Model). It acts as a bridge between React's virtual representation of the UI (Virtual DOM) and the actual HTML DOM in the browser.

Key functions of ReactDOM include:
- `ReactDOM.render()`: This method is used to render React elements (components) to the HTML DOM. It takes a React component and a target DOM element as parameters and renders the component's output to the specified DOM element.
- `ReactDOM.hydrate()`: Similar to `ReactDOM.render()`, but it is used when you have server-rendered HTML and want to add interactivity to it on the client side. It preserves the server-rendered markup and only attaches event handlers and makes the necessary adjustments.

In summary, React is the core library for building UI components and managing the application state, while ReactDOM is a specific package that provides methods to interact with the browser's DOM, allowing React to render components and handle updates in the actual HTML DOM. When building a web application with React, you will likely use both React and ReactDOM to create and render your components.




6. What is the difference between react.development.js and react.production.js files via CDN>
The difference between `react.development.js` and `react.production.js` files lies in how they are optimized for development and production environments.

1. `react.development.js`:
- This file is intended for use during development. It contains additional checks, warnings, and error messages that help developers identify potential issues in their code and provide more detailed feedback.
- It is larger in size compared to `react.production.js` because of the extra development-specific code it includes.
- Using `react.development.js` is recommended during the development phase of your project as it provides more helpful error messages and warnings, making it easier to debug and troubleshoot issues in your React application.

2. `react.production.js`:
- This file is optimized for production environments. It is stripped of development-specific checks, warnings, and error messages to reduce its size and improve performance.
- It is smaller in size compared to `react.development.js` due to the removal of non-essential development code.
- Using `react.production.js` is recommended for your production deployment to minimize the size of your JavaScript bundle and improve the loading time and performance of your React application.

When using React in a project, you should switch to using `react.production.js` for your production builds to get the benefits of a smaller bundle size and improved performance. On the other hand, during development, you can use `react.development.js` to take advantage of additional debugging features and better error messages to help you identify and fix issues more easily.

Both files provide the core functionality of React, but the key distinction lies in the presence of development-specific features in `react.development.js` and the size optimization in `react.production.js`. When deploying your application, make sure to use the appropriate version based on whether you are in development or production mode.




7. What are async and defer?
`async` and `defer` are attributes used in HTML script tags to control how external JavaScript files are loaded and executed on a web page. They both help improve page loading performance, but they work differently and have distinct use cases:

1. `async` Attribute:
- When the `async` attribute is added to a script tag, the browser will continue to load the HTML page and other resources (like CSS and images) without waiting for the script to be fully downloaded and executed.
- Once the external script file is fetched, it will be executed asynchronously, meaning it won't block the HTML parsing or rendering. The script can be executed as soon as it's ready, regardless of whether the rest of the page has finished loading.
- The order of execution may not follow the order of appearance in the HTML document, especially if the script file loads quickly or if there are multiple scripts with the `async` attribute.
- Use `async` for scripts that don't depend on the page's content or other scripts and can run independently.

Example:
```html
<script src="example.js" async></script>
```

2. `defer` Attribute:
- When the `defer` attribute is added to a script tag, the browser will download the script file in the background while parsing the HTML document. However, it will wait to execute the script until the entire HTML document has been parsed.
- Multiple scripts with the `defer` attribute will be executed in the order they appear in the HTML document.
- Use `defer` for scripts that need to be executed after the DOM has been fully loaded but can be deferred until the end to improve page load times.

Example:
```html
<script src="example.js" defer></script>
```

In summary, both `async` and `defer` attributes help improve page loading performance by allowing the HTML document to load in parallel with external script downloads. However, `async` executes the script as soon as it's downloaded, while `defer` waits until the HTML parsing is complete before executing the script in order of appearance. Choose the appropriate attribute based on the script's dependencies and when it should be executed in relation to the loading and parsing of the HTML document.




Assignement - 2

1. What is 'NPM' ?
NPM stands for "Node Package Manager." It is a package manager for Node.js, a popular JavaScript runtime environment that allows developers to run JavaScript code outside of a web browser. NPM is the default and most widely used package manager for the Node.js ecosystem.

NPM serves as a central repository of open-source JavaScript packages, where developers can publish and share their code with others. It simplifies the process of discovering, installing, managing, and updating packages (also known as modules or libraries) needed for Node.js projects.

Key features of NPM include:

1. Package Management: NPM allows developers to search for, install, and manage packages needed for their Node.js projects. It automatically handles dependencies, ensuring that the correct versions of packages are installed.

2. Version Management: NPM allows developers to specify the versions of packages their projects depend on, providing version control and helping to maintain consistency across different projects.

3. Command-Line Interface: NPM provides a command-line interface (CLI) that makes it easy to interact with the package manager, including commands for installing packages, updating packages, and managing project dependencies.

4. Registry: NPM maintains a public registry that hosts thousands of open-source packages. Developers can publish their packages to the registry, making them available to the community.

5. Scripts: NPM supports running custom scripts defined in a project's package.json file, making it convenient to set up build processes, run tests, and automate various tasks associated with the project.

To use NPM, you need to have Node.js installed on your system. When you install Node.js, NPM is automatically installed alongside it. This allows you to use NPM commands in your terminal or command prompt to manage Node.js packages in your projects.

In summary, NPM is a package manager for Node.js that simplifies the process of finding, installing, and managing JavaScript packages, enabling developers to leverage a vast ecosystem of open-source tools and libraries to build powerful and scalable applications using Node.js.




2. What is Parcel/Webpack? Why do we need it?
Parcel and Webpack are both popular bundlers used in modern web development to bundle and optimize web assets, such as JavaScript, CSS, images, and more. They help manage dependencies, enable advanced features like code splitting and tree shaking, and improve performance by reducing file sizes and load times.

1. Parcel:
Parcel is a "zero-configuration" bundler, meaning it requires minimal configuration to get started. It automatically detects and handles dependencies, making it straightforward for developers to bundle their projects without the need for extensive configuration files. Parcel supports various asset types out of the box and uses a smart caching mechanism to speed up rebuild times during development.

2. Webpack:
Webpack is a powerful and highly configurable bundler. It allows developers to define custom build processes through a configuration file (webpack.config.js). Webpack provides a wide range of loaders and plugins to process different types of assets and perform tasks like transpilation, minification, and optimization. It supports advanced features like code splitting, lazy loading, and tree shaking, which help reduce the size of the final bundle and improve performance.

Why do we need bundlers like Parcel or Webpack?

1. Code Organization: As web applications grow in complexity, they consist of multiple JavaScript files, CSS files, images, and other assets. Bundlers help organize and merge these files into a single or multiple bundles, making the codebase more manageable and reducing the number of HTTP requests needed to load the application.

2. Dependency Management: Bundlers handle dependencies between files, ensuring that they are loaded in the correct order and avoiding conflicts. This is crucial when working with modern JavaScript frameworks and libraries that often rely on multiple dependencies.

3. Performance Optimization: Bundlers optimize assets by minifying code (removing unnecessary spaces and characters), transpiling modern JavaScript to ensure backward compatibility, and compressing images. These optimizations reduce file sizes and improve the overall loading speed of the web application.

4. Advanced Features: Bundlers like Webpack and Parcel support advanced features like code splitting and lazy loading, which allow parts of the application to be loaded on demand, reducing the initial loading time and improving user experience.

In summary, Parcel and Webpack are powerful tools used to bundle, optimize, and manage web assets in modern web development. They help improve code organization, optimize performance, and provide various advanced features that enable developers to build efficient and high-performing web applications. The choice between Parcel and Webpack often depends on the project's complexity and the level of configuration control needed by the development team.






3. What is .parcel-cache?
`.parcel-cache` is a directory that is automatically generated by the Parcel bundler during the development process. Parcel uses this directory to cache various assets and build artifacts to speed up subsequent builds and improve development performance.

When you run a development server or build your project with Parcel, it analyzes the project's dependencies, processes assets, and generates output bundles. Instead of redoing all these steps from scratch every time you make changes, Parcel saves the intermediate build results in the `.parcel-cache` directory.

The `.parcel-cache` directory typically contains the following types of cached files:

1. Dependency Cache: Parcel caches information about the project's dependencies, such as installed packages, resolved modules, and their versions. This allows it to skip reanalyzing dependencies that have not changed since the last build.

2. Intermediate Build Artifacts: During the bundling process, Parcel generates intermediate build artifacts like transpiled JavaScript, minified CSS, and optimized images. These artifacts are stored in the `.parcel-cache` directory to avoid redundant processing and speed up rebuilds.

3. Cache Validation: Parcel uses a cache validation mechanism to determine if any files have changed since the last build. If it finds that a file has changed, it will only recompile the affected parts, saving time and resources.

The `.parcel-cache` directory is generally automatically managed by Parcel, and developers typically do not need to interact with it directly. However, it's worth noting that in some cases, issues with the caching mechanism may arise, leading to unexpected behavior or outdated build results. In such cases, deleting the `.parcel-cache` directory and performing a clean build can help resolve the problem.

As the cache is primarily intended to speed up development builds, it's generally safe to clear the `.parcel-cache` directory when moving the project to production or when troubleshooting build-related issues. Keep in mind that doing so will slow down the next development build, as Parcel will need to reprocess all the assets and dependencies from scratch.




4. What is npx?
`npx` is a command-line tool that comes bundled with `npm` (Node Package Manager) starting from version 5.2.0. It stands for "Node Package eXecute" and is used to execute Node.js packages directly from the command line, without the need to install them globally or locally on your machine.

Before the introduction of `npx`, when you wanted to run a package installed via `npm`, you had to install it globally or locally first. Global installations could cause version conflicts and clutter the global package space, while local installations required you to manage dependencies within each project.

With `npx`, you can execute a package without explicitly installing it. When you run `npx some-package`, `npx` automatically looks for the package in the local `node_modules` folder of your project, and if it's not found, it temporarily installs the package in a temporary directory before executing it. After execution, the temporary package is removed, avoiding any global or local installation conflicts.

This feature is particularly useful for running command-line tools, one-off scripts, or utilities provided by packages without polluting your global or project dependencies. Additionally, `npx` ensures that you are running the version of the package listed in your project's `package.json`, providing a consistent environment for execution.

For example, to run a one-off script provided by a package named `my-package`, you can use `npx` as follows:

```bash
npx my-package
```

This will execute the `my-package` script from the locally installed version in your project's `node_modules`, or it will temporarily install it if not found.

By using `npx`, you can take advantage of the vast ecosystem of Node.js packages without worrying about global or local installations and version conflicts. It's an essential tool for modern Node.js development and command-line scripting.




5. What is the difference between dependencies and devDependencies?
In the context of Node.js and npm (Node Package Manager), "dependencies" and "devDependencies" are two different categories used to specify the packages required for a project. They serve distinct purposes and are used in different scenarios:

1. Dependencies:
- "dependencies" refer to the packages that are necessary for the application to run in production or when deployed. These are the packages that your application relies on to function correctly and provide its core functionality.
- When someone installs your application or deploys it to a server, npm will automatically install the packages listed in the "dependencies" section of your project's `package.json` file. These packages will be included in the production build or deployment.
- Examples of packages that typically belong in "dependencies" are frameworks, libraries, and utilities that are used throughout your application.

Example `package.json` with "dependencies":

```json
{
  "name": "my-app",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.17.1",
    "axios": "^0.21.1"
  }
}
```

2. devDependencies:
- "devDependencies" refer to the packages that are only required during development and are not necessary for the application to run in production.
- These packages are used for development tasks such as building, testing, linting, and other development-related operations. They are not included in the production build or deployment to reduce the size and dependencies of the final application.
- When someone clones your project from a version control repository and wants to contribute or run development tasks, npm will install the packages listed in the "devDependencies" section of your `package.json`.

Example `package.json` with "devDependencies":

```json
{
  "name": "my-app",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.17.1"
  },
  "devDependencies": {
    "jest": "^27.0.6",
    "eslint": "^7.32.0"
  }
}
```

In summary, "dependencies" are packages required for the application to run in production, while "devDependencies" are packages used during development but not included in the production build. Separating these two categories helps keep the production build lean and avoids unnecessary dependencies that could affect the application's performance.




6. What is Tree Shaking?
Tree shaking is a technique used in modern JavaScript build tools, such as Webpack and Rollup, to eliminate dead or unused code (dead code elimination) from the final bundled output. The term "tree shaking" comes from the process of shaking the tree of dependencies and dropping any branches (code) that are not being used, effectively reducing the bundle size.

When you bundle a JavaScript application, it may contain various functions, classes, or modules that are imported but never actually used in the application. Tree shaking identifies and removes these unused pieces of code during the build process, resulting in a smaller, more efficient, and optimized output.

Key points about tree shaking:

1. Granularity: Tree shaking works at the level of individual functions or modules. It analyzes the import and export statements in the code to determine which functions or modules are being used and which are not.

2. ES Modules: Tree shaking is particularly effective with ES modules (import and export statements) since they have a clear and static structure, making it easier for the build tools to analyze dependencies.

3. Dead Code Elimination: By removing unused code, tree shaking reduces the size of the final bundle, leading to faster load times and improved application performance.

4. Minification: Tree shaking works in conjunction with minification (removing whitespace, renaming variables, etc.) to further optimize the bundle size.

5. Side Effects: Tree shaking only removes code that is not being used. Code with side effects (e.g., modifying the DOM, making network requests) is generally retained, even if it is not directly referenced, to preserve the intended behavior of the application.

To enable tree shaking in your JavaScript project, you need to use a build tool that supports this feature, such as Webpack or Rollup. Additionally, it's essential to use ES modules (import and export syntax) in your codebase for tree shaking to work effectively.

In summary, tree shaking is a valuable optimization technique that helps eliminate unused code from JavaScript bundles, resulting in smaller, more efficient applications with improved performance and faster load times.




7. What is Hot Module Replacement?
Hot Module Replacement (HMR) is a feature in modern JavaScript build tools and frameworks, such as Webpack and React, that allows developers to update modules or components in real-time without requiring a full page refresh. It enhances the development experience by providing a more responsive and efficient workflow during development.

With HMR, when a developer makes changes to the source code (e.g., JavaScript, CSS, or templates), the build tool detects those changes and pushes the updated modules to the browser without reloading the entire page. The changes are reflected instantly, preserving the application state and avoiding the need to manually navigate back to the desired state after each change.

Key features of Hot Module Replacement:

1. Real-time Updates: HMR enables the automatic replacement of modified modules or components in the browser without reloading the entire page, allowing developers to see the changes instantly.

2. Retaining Application State: HMR keeps the application state intact during the update process. This means that if you are working on a specific page or have certain data in memory, it will persist after the module update.

3. Faster Development Workflow: HMR significantly reduces development iteration times by eliminating the need for full page reloads. It enables a more efficient and productive development experience.

4. Module Preservation: HMR works at the level of individual modules, updating only the affected modules while preserving the rest of the application's state and components.

5. Error Recovery: If a hot update encounters an error during the replacement process, HMR will fall back to a full page reload, preventing the application from entering an inconsistent state.

HMR is particularly useful in development environments, where developers frequently make changes to the code and want to see the immediate impact without the overhead of full-page reloads. It is commonly used in conjunction with development servers that support HMR, such as `webpack-dev-server` or `react-scripts`, to provide a seamless development experience.

HMR is not intended for use in production environments, where optimizations like code splitting and minification should be employed to reduce bundle sizes. Instead, in production, the application should be fully built and optimized for performance.




8. What is .gitignore? What should we add and not add into it?
`.gitignore` is a text file used by the version control system Git to specify which files and directories should be ignored and not tracked by Git. When you add files or directories to the `.gitignore` file, Git will exclude them from being committed to the repository and prevent them from being part of the version history.

The main purpose of the `.gitignore` file is to avoid cluttering the repository with unnecessary files, such as build artifacts, editor-specific files, and sensitive information. It helps to keep the repository clean and focused on the source code and essential project files.

What to add to `.gitignore`:

1. Build Artifacts: Any files generated during the build process, such as compiled binaries, minified CSS or JavaScript, and intermediate build output, should be added to `.gitignore`.

2. Dependency Directories: Folders like `node_modules` (for Node.js projects) and `vendor` (for PHP projects) that contain dependencies installed by package managers should be ignored, as they can be easily reinstalled by running package installation commands.

3. Editor/IDE-specific Files: Files created by code editors or IDEs, like `.vscode`, `.idea`, `.DS_Store`, and `.project`, should be ignored, as they are specific to the developer's environment.

4. Log Files: Logs generated during development or application runtime should be added to `.gitignore` to avoid unnecessary clutter in the repository.

5. Sensitive Information: Sensitive files, such as API keys, credentials, and configuration files containing sensitive data, should be ignored to prevent accidental exposure of sensitive information.

What not to add to `.gitignore`:

1. Source Code: Never add actual source code files (e.g., `.js`, `.css`, `.html`) to `.gitignore`. The purpose of version control is to track changes in the source code.

2. Configuration Templates: Template files used to generate configuration files, like `.env.example` or `config.json.template`, should not be added to `.gitignore`. Instead, include them in the repository to provide clear guidelines for configuration setup.

3. Important Documentation: Avoid adding essential documentation or license files to `.gitignore`. These files are valuable for developers and users, and excluding them from version control is not recommended.

4. `.gitignore` Itself: Do not add `.gitignore` to itself. The `.gitignore` file should be part of the version control system to ensure that everyone working on the project follows the same ignore rules.

Always review and double-check the entries in `.gitignore` to make sure you are excluding the right files and directories from version control. Keeping the repository clean and free from unnecessary files ensures a more focused and efficient version control workflow.




9. What is the difference between package.json and package-lock.json?
`package.json` and `package-lock.json` are both important files used in Node.js projects managed by npm (Node Package Manager). They serve different purposes and work together to ensure consistent and reproducible installations of packages.

1. `package.json`:
- `package.json` is a metadata file that contains information about the project and its dependencies. It serves as the manifest for the project, listing all the dependencies required to run the application and specifying other project details such as the project name, version, author, scripts, and more.
- Developers manually manage the content of `package.json`, and it can be edited to add or remove dependencies or to specify required versions.
- When someone clones the project or runs `npm install`, npm reads the `package.json` file and installs the dependencies listed there, including their transitive dependencies.

Example `package.json`:

```json
{
  "name": "my-app",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.17.1",
    "lodash": "^4.17.21"
  },
  "devDependencies": {
    "jest": "^27.0.6",
    "eslint": "^7.32.0"
  }
}
```

2. `package-lock.json`:
- `package-lock.json` is a automatically generated file that provides a complete and detailed list of all the dependencies installed in the project. It includes the specific version of each package and their transitive dependencies, along with their unique identifiers (SHAs) to ensure reproducible installations.
- The `package-lock.json` file is automatically created or updated whenever you run `npm install`. It acts as a lockfile to "lock" the dependency tree to specific versions, ensuring that everyone working on the project installs the exact same versions of dependencies.
- The presence of `package-lock.json` helps in avoiding dependency version conflicts and ensures consistency across different development environments.

The use of both `package.json` and `package-lock.json` is crucial for proper dependency management. Developers manage the project's dependencies in `package.json`, while `package-lock.json` is generated by npm to provide deterministic installations. Together, they help create a stable and reproducible development environment for Node.js projects.

It's important to version-control both `package.json` and `package-lock.json` files in the project's version control system to ensure consistent and accurate dependency management across different team members and deployment environments.




10. Why should i not modify package-lock.json?
`package-lock.json` should not be manually modified for several important reasons:

1. Reproducible Installations: The purpose of `package-lock.json` is to provide a deterministic and reproducible installation of dependencies. It locks the dependency tree to specific versions, ensuring that everyone working on the project installs the exact same versions of packages. Modifying `package-lock.json` manually can lead to inconsistent installations and version conflicts, making it challenging to reproduce the same environment across different machines.

2. Automatic Generation: `package-lock.json` is automatically generated by npm whenever you run `npm install` or `npm update`. It reflects the actual installed versions of packages based on the `dependencies` and `devDependencies` defined in `package.json`. Manual changes can introduce errors or conflicts with the actual installed packages, leading to unexpected behavior and difficult-to-debug issues.

3. Team Collaboration: In a team environment, all team members should use the same versions of dependencies to avoid compatibility issues and ensure consistent development. If a team member manually modifies `package-lock.json`, it can lead to inconsistencies across the team and make it challenging to collaborate effectively.

4. Dependency Integrity: Modifying `package-lock.json` can compromise the integrity of your project's dependencies. It is designed to provide a complete and accurate list of dependencies and their versions, ensuring that no unauthorized changes are introduced into the project.

5. Version Control: Both `package.json` and `package-lock.json` should be version-controlled to track changes in dependencies over time accurately. If you manually modify `package-lock.json`, it can lead to unnecessary and misleading changes in the version control history, making it difficult to understand the actual changes made to dependencies.

If you need to update or change dependencies, you should do it through the `package.json` file, not by modifying `package-lock.json`. By updating the dependency versions in `package.json` and running `npm install` or `npm update`, npm will automatically regenerate the `package-lock.json` with the correct and updated versions, ensuring a consistent and reproducible installation of dependencies.




11. What is node_modules? Why its not a good idea to not push that on git?
`node_modules` is a directory created in your Node.js project when you run `npm install` or `yarn install`. It contains all the packages (dependencies) that your project requires to run. These packages are specified in your project's `package.json` file, and `node_modules` contains the actual code and files of those packages.

Here's why it's generally not a good idea to push `node_modules` to Git:

1. Large Size: The `node_modules` directory can be quite large, especially for projects with many dependencies. Including it in your Git repository can significantly increase the repository size, making it slower to clone and consume more storage space.

2. Reproducible Builds: Pushing `node_modules` to Git is unnecessary because the same dependencies can be easily installed by other developers by running `npm install` or `yarn install` based on the `package.json` and `package-lock.json`/`yarn.lock` files. By avoiding pushing `node_modules`, you ensure that each developer installs the same versions of dependencies, leading to reproducible builds across different environments.

3. Faster Git Operations: Excluding `node_modules` from Git reduces the size of your repository, making Git operations like cloning, pulling, and pushing faster and more efficient.

4. Git Ignore Best Practice: It's a common best practice to include `node_modules` in the `.gitignore` file to avoid accidentally committing this directory. Ignoring `node_modules` prevents unnecessary changes from being tracked in your Git history.

5. Smaller Repository Backups: If you are backing up your Git repository regularly, excluding `node_modules` means faster and smaller backups since the node packages can be easily reinstalled by running `npm install` or `yarn install`.

Instead of pushing `node_modules` to Git, you should include `node_modules` in your `.gitignore` file to exclude it from version control. When another developer clones your repository, they can run `npm install` or `yarn install` to fetch all the necessary dependencies and build the `node_modules` directory locally. Additionally, when deploying the application to a production environment, the server can install the dependencies from the `package.json` using `npm install` or `yarn install`, ensuring that the correct versions are installed for production use.




12. What is the dist folder?
The "dist" folder, short for "distribution" folder, is a common directory name used in web development projects, particularly those using build tools like Webpack, Rollup, or Parcel. It is the output directory where the final and optimized build of the web application is generated after running the build process.

In the "dist" folder, you will find the production-ready and optimized version of your application that is ready to be deployed to a web server or hosting platform. This folder typically contains minified and concatenated files, as well as other assets like images and CSS files that are optimized for performance.

The content of the "dist" folder may vary based on the project setup and build configuration. However, it usually includes:

1. Minified and Bundled JavaScript: The main JavaScript file(s) that are minified (code compressed) and bundled together, often including third-party libraries and application code.

2. Minified CSS: The CSS files, usually concatenated and minified to reduce file size and improve loading speed.

3. HTML Files: The HTML files required for the application's entry points, often including a single HTML file that loads the bundled JavaScript and CSS.

4. Optimized Images: Images used in the application that have been compressed and optimized to reduce file size without significant loss in quality.

5. Other Assets: Any other assets like fonts, icons, or static files used in the application.

The "dist" folder is typically not included in version control systems like Git because it contains build artifacts that can be easily regenerated by running the build process on the project. It is considered best practice to exclude the "dist" folder (along with other build output folders like "node_modules") from version control and include it in the project's .gitignore file.

When deploying a web application, developers often upload the contents of the "dist" folder to the web server or a hosting platform, ensuring that the optimized and production-ready version of the application is served to users.




13. What is Browserslist?
The correct term is "Browserslist" (not "browserlists"), and it is a popular and widely used configuration file in web development to specify which browsers your project supports. Browserslist is used by various build tools and libraries, such as Autoprefixer, Babel, and CSS minifiers, to determine which browser-specific prefixes, polyfills, and transpilations are necessary for your CSS and JavaScript to ensure cross-browser compatibility.

The main purpose of Browserslist is to make it easier for developers to target specific browsers and their versions, without needing to write vendor-specific prefixes manually or manage browser compatibility concerns separately for each tool.




14.Bundlers vite,webpack and parcel?
Vite, Webpack, and Parcel are all popular JavaScript bundlers used in modern web development to bundle and optimize web assets. While they share the same goal of bundling assets, they have different approaches and features that set them apart:

1. Vite:
- Vite is a modern build tool and development server designed specifically for building web applications with Vue.js and React, although it can also be used for other frameworks and vanilla JavaScript projects.
- Vite leverages native ES modules in modern browsers during development, which allows for extremely fast development server startup and hot module replacement (HMR).
- It uses a "dev server-first" approach, where the development server serves the unbundled and untranspiled code directly to the browser. This speeds up the development workflow as there is no need to bundle the entire application during development.
- For production builds, Vite uses Rollup as the underlying bundler to generate optimized and minified production bundles.

2. Webpack:
- Webpack is a powerful and highly configurable bundler used in a wide range of web applications. It supports bundling not only JavaScript but also CSS, images, fonts, and other assets.
- It can handle complex build processes and has extensive support for code splitting, tree shaking, and various optimizations to create efficient and performant bundles.
- Webpack has a vibrant ecosystem with a vast number of plugins and loaders, which allows developers to customize the build process to meet specific project requirements.
- Due to its flexibility and configurability, Webpack is suitable for both small and large-scale projects and can be used with various frontend frameworks and libraries.

3. Parcel:
- Parcel is a "zero-configuration" bundler, meaning it requires minimal configuration to get started and can handle a wide range of assets out of the box.
- It provides a simple and easy-to-use development experience, automatically handling dependencies and supporting features like hot module replacement (HMR) without additional configuration.
- Parcel is well-suited for small to medium-sized projects and is especially popular for quickly setting up static sites or simple web applications with minimal setup.

In summary, Vite, Webpack, and Parcel are all powerful bundlers used in modern web development. Vite is optimized for fast development workflows with Vue.js and React, Webpack is highly configurable and suitable for various types of projects, and Parcel is a simple and easy-to-use bundler for small to medium-sized projects. The choice between these bundlers often depends on the project's specific requirements, complexity, and the desired development experience.
